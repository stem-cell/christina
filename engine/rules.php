<?php namespace Christina;

// Deals with loading and handling of post search (query) rules.
class Rules
{
    // A value indicating whether rules have been initialized.
    static $initialized = false;

    // Loads all rules.
    static function init()
    {
        if (!Rules::$initialized)
        {
            $base = dirname(__DIR__);
            requireDir("$base/rules");
            Rules::$initialized = true;
        }
    }

    // Returns all Rule subclasses.
    static function allRules()
    {
        return getSubclassesOf('Christina\Rule');
    }

    // Tries to parse a textual rule representation into a Rule object and return it.
    // If no rule object is capable of understanding its construct, null is returned.
    static function tryParse($ruleText)
    {
        foreach (Rules::allRules() as $rule)
        {
            $parsed = $rule::tryParse($ruleText);
            if ($parsed) return $parsed;
        }

        return null; // No Rule subclass could parse it.
    }
}

// Base rule, from which others inherit.
abstract class Rule
{
    // Rule data.
    protected $data;

    // Type that the data should conform to, if any.
    // Can be a scalar name (like 'string' or 'array') or a class name (like 'MyClass').
    // If null, will mean "doesn't matter".
    protected $type = null;

    // Operation mode. This is used to easily provide subclasses that negate a rule.
    // Setting it to false should make a rule negative, such as matching posts
    // that don't have a given property instead of those who do.
    static protected $mode = true;

    // Pattern that a textual representation of the rule should match.
    // It is encouraged to use named subpatterns for clarity.
    // The pattern is to be wrapped like so: "/^$pattern\$/i". Therefore,
    // you don't need to include these characters.
    static protected $pattern = '.*'; // Matches anything.

    // Builds the rule from the passed data, optionally parsing the data
    // with an overridden ->parse() method.
    function __construct($data)
    {
        $this->validateType($data);
        $this->data = $this->parse($data);
    }

    // Override this method to provide custom parsing logic.
    function parse($data)
    {
        return $data;
    }

    // Validates the type as per $this->type.
    // If you override this function, more complex logic can be executed,
    // and $this->type wll not need to be used.
    // Note that the validation is not done by returning true or false
    // but by throwing an exception on mismatch.
    function validateType($data)
    {
        // Only do anything if type is set.
        if (!$this->type) return;

        if (!is($this->type, $data))
        {
            throw new TypeException();
        }
    }

    // Check a post against our rule.
    // This function should return true if the post matches the rule.
    abstract function check(Post $post);

    // Tries to parse the rule according to the rule's declared ::$pattern.
    // If that works, returns an instance built from ::fromMatch().
    // If it doesn't, returns null.
    static function tryParse($ruleText)
    {
        $rule = get_called_class();
        $pattern = str_replace('/', '\\/', $rule::$pattern);

        if (preg_match("/^$pattern$/i", $ruleText, $matches))
        {
            return $rule::fromMatch($matches);
        }
        else
        {
            return null;
        }
    }

    // You may implement this function in derived classes.
    // It should return a new instance of the Rule subclass from
    // the matches generated by parsing a textual representation of the
    // rule with the ::$pattern defined in the subclass.
    // The current implementation will work for any pattern that only
    // has a single named matching group.
    static function fromMatch($match)
    {
        $rule = get_called_class(); // Current subclass.
        foreach ($match as $key => $value)
        {
            // Use first matched rule.
            if (is_string($key)) return new $rule($value);
        }
        return null;
    }
}
